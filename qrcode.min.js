
(function(global) {
    'use strict';
    
    function QRCode() {}
    
    QRCode.toCanvas = function(canvas, text, options) {
        return new Promise((resolve, reject) => {
            try {
                options = options || {};
                const size = options.width || 300;
                
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = options.color?.light || '#FFFFFF';
                ctx.fillRect(0, 0, size, size);
                
                generateQRFromAPI(text, size, options)
                    .then(imageData => {
                        if (imageData) {
                            const img = new Image();
                            img.onload = function() {
                                if (options.color?.dark && options.color.dark !== '#000000') {
                                    applyCustomColors(ctx, img, size, options.color);
                                } else {
                                    ctx.drawImage(img, 0, 0, size, size);
                                }
                                resolve(canvas);
                            };
                            img.onerror = function() {
                                generateLocalQR(ctx, text, size, options);
                                resolve(canvas);
                            };
                            img.src = imageData;
                        } else {
                            generateLocalQR(ctx, text, size, options);
                            resolve(canvas);
                        }
                    })
                    .catch(error => {
                        console.log('API fallback, usando generación local');
                        generateLocalQR(ctx, text, size, options);
                        resolve(canvas);
                    });
                    
            } catch (error) {
                reject(error);
            }
        });
    };
    
    async function generateQRFromAPI(text, size, options) {
        const apis = [
            {
                url: `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(text)}&format=PNG&ecc=M`,
                method: 'GET'
            },
            {
                url: `https://api.qrcode-monkey.com/qr/custom`,
                method: 'POST',
                body: {
                    data: text,
                    config: {
                        body: 'square',
                        eye: 'frame0',
                        eyeBall: 'ball0',
                        erf1: [],
                        erf2: [],
                        erf3: [],
                        brf1: [],
                        brf2: [],
                        brf3: [],
                        bodyColor: '#000000',
                        bgColor: '#FFFFFF',
                        eye1Color: '#000000',
                        eye2Color: '#000000',
                        eye3Color: '#000000',
                        eyeBall1Color: '#000000',
                        eyeBall2Color: '#000000',
                        eyeBall3Color: '#000000',
                        gradientColor1: '',
                        gradientColor2: '',
                        gradientType: 'linear',
                        gradientOnEyes: 'true',
                        logo: ''
                    },
                    size: size,
                    download: false,
                    file: 'png'
                }
            },
            {
                url: `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(text)}&format=PNG&margin=0`,
                method: 'GET'
            }
        ];
        
        for (let api of apis) {
            try {
                let response;
                if (api.method === 'POST') {
                    response = await fetch(api.url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(api.body)
                    });
                } else {
                    response = await fetch(api.url);
                }
                
                if (response.ok) {
                    const blob = await response.blob();
                    return URL.createObjectURL(blob);
                }
            } catch (error) {
                console.log(`API ${api.url} falló, probando siguiente...`);
                continue;
            }
        }
        
        return null;
    }
    
    function applyCustomColors(ctx, img, size, colors) {
        ctx.drawImage(img, 0, 0, size, size);
        
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        const darkColor = hexToRgb(colors.dark || '#000000');
        const lightColor = hexToRgb(colors.light || '#FFFFFF');
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            const brightness = (r + g + b) / 3;
            
            if (brightness < 128) {
                data[i] = darkColor.r;
                data[i + 1] = darkColor.g;
                data[i + 2] = darkColor.b;
            } else {
                data[i] = lightColor.r;
                data[i + 1] = lightColor.g;
                data[i + 2] = lightColor.b;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    
    function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 0, g: 0, b: 0};
    }
    
    function generateLocalQR(ctx, text, size, options) {
        const qrSize = 25;
        const moduleSize = Math.floor(size / qrSize);
        const margin = Math.floor((size - (qrSize * moduleSize)) / 2);
        
        ctx.fillStyle = options.color?.light || '#FFFFFF';
        ctx.fillRect(0, 0, size, size);
        
        const matrix = generateSimpleQRMatrix(text, qrSize);
        
        ctx.fillStyle = options.color?.dark || '#000000';
        for (let i = 0; i < qrSize; i++) {
            for (let j = 0; j < qrSize; j++) {
                if (matrix[i][j]) {
                    ctx.fillRect(
                        margin + j * moduleSize,
                        margin + i * moduleSize,
                        moduleSize,
                        moduleSize
                    );
                }
            }
        }
    }
    
    function generateSimpleQRMatrix(text, size) {
        const matrix = Array(size).fill().map(() => Array(size).fill(0));
        
        addFinderPattern(matrix, 0, 0);
        addFinderPattern(matrix, 0, size - 7);
        addFinderPattern(matrix, size - 7, 0);
        
        addSeparators(matrix, size);
        
        for (let i = 8; i < size - 8; i++) {
            matrix[6][i] = i % 2 === 0 ? 1 : 0;
            matrix[i][6] = i % 2 === 0 ? 1 : 0;
        }
        
        fillDataArea(matrix, text, size);
        
        return matrix;
    }
    
    function addFinderPattern(matrix, startRow, startCol) {
        for (let i = 0; i < 7; i++) {
            for (let j = 0; j < 7; j++) {
                matrix[startRow + i][startCol + j] = 1;
            }
        }
        
        for (let i = 1; i < 6; i++) {
            for (let j = 1; j < 6; j++) {
                matrix[startRow + i][startCol + j] = 0;
            }
        }
        
        for (let i = 2; i < 5; i++) {
            for (let j = 2; j < 5; j++) {
                matrix[startRow + i][startCol + j] = 1;
            }
        }
    }
    
    function addSeparators(matrix, size) {
        const positions = [[0, 0], [0, size - 7], [size - 7, 0]];
        
        positions.forEach(([row, col]) => {
            for (let j = -1; j <= 7; j++) {
                if (row - 1 >= 0 && col + j >= 0 && col + j < size) {
                    matrix[row - 1][col + j] = 0;
                }
                if (row + 7 < size && col + j >= 0 && col + j < size) {
                    matrix[row + 7][col + j] = 0;
                }
            }
            
            for (let i = -1; i <= 7; i++) {
                if (row + i >= 0 && row + i < size && col - 1 >= 0) {
                    matrix[row + i][col - 1] = 0;
                }
                if (row + i >= 0 && row + i < size && col + 7 < size) {
                    matrix[row + i][col + 7] = 0;
                }
            }
        });
    }
    
    function fillDataArea(matrix, text, size) {
        let hash = 0;
        for (let i = 0; i < text.length; i++) {
            hash = ((hash << 5) - hash + text.charCodeAt(i)) & 0xffffffff;
        }
        
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                if (!isReservedArea(i, j, size)) {
                    const value = (hash + i * 7 + j * 11 + text.charCodeAt(i % text.length)) % 100;
                    matrix[i][j] = value < 45 ? 1 : 0;
                }
            }
        }
    }
    
    function isReservedArea(row, col, size) {
        if ((row < 9 && col < 9) || 
            (row < 9 && col >= size - 8) || 
            (row >= size - 8 && col < 9)) {
            return true;
        }
        
        if (row === 6 || col === 6) {
            return true;
        }
        
        return false;
    }
    
    global.QRCode = QRCode;
    
    setTimeout(() => {
        const event = new CustomEvent('qrcodeReady');
        global.dispatchEvent(event);
    }, 100);
    
})(window);
